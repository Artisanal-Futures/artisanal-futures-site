/* eslint-disable react-hooks/exhaustive-deps */

import dynamic from "next/dynamic";

import React, { useEffect, useState, type FC } from "react";

import { supabase } from "~/server/supabase/client";

import "leaflet-geosearch/dist/geosearch.css";
import "leaflet/dist/leaflet.css";
import type { GetServerSidePropsContext } from "next";
import { Beforeunload } from "react-beforeunload";

import type { RouteData, StepData } from "~/components/tools/routing/types";
import { Button } from "~/components/ui/button";

import { useParams } from "next/navigation";

import StopDetails from "~/components/tools/routing/tracking/stop-details";

import { DriverRouteBreakdown } from "~/components/tools/routing/solutions/driver-route-breakdown";

import Head from "next/head";
import LoadingIndicator from "~/components/tools/routing/solutions/loading-indicator";
import { useDriverRoute } from "~/hooks/routing/use-driver-routes";
import useRealTime from "~/hooks/routing/use-realtime";
import RouteLayout from "~/layouts/route-layout";
import { parseIncomingDBData } from "~/utils/routing/file-handling";

interface IProps {
  data: RouteData;
  steps: StepData[];
}

const LazyDriverMap = dynamic(
  () => import("~/components/tools/routing/map/driver-map"),
  {
    loading: () => <p>Loading...</p>,
    ssr: false,
  }
);

const RoutePage: FC<IProps> = ({ data, steps }) => {
  const { route } = useParams();

  const { stops, setStops, selectedStop } = useDriverRoute((state) => state);
  const { isTrackingCurrentUser, setIsTrackingCurrentUser } = useRealTime(
    data,
    route as string
  );

  const [open, setOpen] = useState(false);

  useEffect(() => {
    if (steps) setStops(steps);
  }, [steps]);

  // If user clicks on a stop, open the stop details modal
  useEffect(() => {
    if (selectedStop) setOpen(true);
  }, [selectedStop]);

  return (
    <>
      <Head>
        <title>Route Details | Artisanal Futures</title>
        <meta name="description" content="Generated by create-t3-app" />{" "}
        <meta
          name="viewport"
          content="width=device-width,height=device-height initial-scale=1"
        ></meta>
        <link rel="icon" href="/favicon.ico" />{" "}
      </Head>
      <RouteLayout>
        <section className="flex flex-1  flex-col-reverse border-2 lg:flex-row">
          <div className="flex w-full flex-col gap-4 max-lg:h-4/6 max-md:overflow-y-auto lg:w-5/12 xl:w-3/12">
            <>
              <Beforeunload
                onBeforeunload={(event) => {
                  event.preventDefault();
                }}
              />
              {steps.length > 0 && (
                <DriverRouteBreakdown
                  data={data}
                  steps={stops}
                  textColor={data?.vehicle}
                />
              )}
              <Button
                onClick={() => setIsTrackingCurrentUser(true)}
                disabled={isTrackingCurrentUser}
                variant={isTrackingCurrentUser ? "secondary" : "default"}
              >
                {isTrackingCurrentUser && <LoadingIndicator />}
                {isTrackingCurrentUser
                  ? "Broadcasting location with dispatch..."
                  : "Start Route"}
              </Button>{" "}
              {isTrackingCurrentUser && (
                <Button
                  onClick={() => setIsTrackingCurrentUser(false)}
                  variant={"default"}
                >
                  Stop broadcasting location with dispatch
                </Button>
              )}
              {selectedStop && (
                <StopDetails open={open} setOpen={setOpen} routeData={data} />
              )}
            </>
          </div>
          <div className="z-0 flex w-full flex-col  max-lg:grow lg:w-7/12 xl:w-9/12">
            {data?.geometry && stops && (
              <LazyDriverMap
                steps={stops}
                focusedStop={selectedStop}
                vehicle={data}
              />
            )}
          </div>
        </section>
      </RouteLayout>
    </>
  );
};

export const getServerSideProps = async (
  context: GetServerSidePropsContext
) => {
  const { data, error } = await supabase.storage
    .from("routes")
    .download(`${context.query.route as string}.json`);

  if (!data || error)
    return {
      redirect: {
        destination: `/tools/routing`,
        permanent: false,
      },
    };

  const jsonObject = await parseIncomingDBData(data);

  return { props: { data: jsonObject, steps: jsonObject.steps } };
};

export default RoutePage;
