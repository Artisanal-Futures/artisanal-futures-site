/* eslint-disable react-hooks/exhaustive-deps */

import dynamic from "next/dynamic";

import React, { useCallback, useEffect, useState, type FC } from "react";

import { supabase } from "~/server/supabase/client";

import "leaflet-geosearch/dist/geosearch.css";
import "leaflet/dist/leaflet.css";
import type { GetServerSidePropsContext } from "next";
import { Beforeunload } from "react-beforeunload";

import type { RouteData, StepData } from "~/components/tools/routing/types";
import { Button } from "~/components/ui/button";

import { useParams } from "next/navigation";

import StopDetails from "~/components/tools/routing/tracking/stop-details";

import { DriverRouteBreakdown } from "~/components/tools/routing/solutions/driver-route-breakdown";

import Head from "next/head";
import LoadingIndicator from "~/components/tools/routing/solutions/loading-indicator";
import { useDriverRoute } from "~/hooks/routing/use-driver-routes";
import useRealTime from "~/hooks/routing/use-realtime";
import RouteLayout from "~/layouts/route-layout";
import { parseIncomingDBData } from "~/utils/routing/file-handling";

interface IProps {
  data: RouteData;
  steps: StepData[];
}

const LazyDriverMap = dynamic(
  () => import("~/components/tools/routing/map/driver-map"),
  {
    loading: () => <p>Loading...</p>,
    ssr: false,
  }
);

const RoutePage: FC<IProps> = ({ data, steps }) => {
  const { route } = useParams();

  const { stops, setStops, selectedStop } = useDriverRoute((state) => state);
  const { isTrackingCurrentUser, setIsTrackingCurrentUser } = useRealTime(
    data,
    route as string
  );

  const [open, setOpen] = useState(false);

  useEffect(() => {
    if (steps) setStops(steps);
  }, [steps]);

  // If user clicks on a stop, open the stop details modal
  useEffect(() => {
    if (selectedStop) setOpen(true);
  }, [selectedStop]);

  return (
    <>
      <Head>
        <title>Route Details | Artisanal Futures</title>
        <meta name="description" content="Generated by create-t3-app" />
        <link rel="icon" href="/favicon.ico" />{" "}
      </Head>
      <RouteLayout>
        <section className="flex flex-1 flex-row border-2 ">
          <div className="flex flex-col gap-2">
            <Beforeunload
              onBeforeunload={(event) => {
                event.preventDefault();
              }}
            />
            {steps.length > 0 && (
              <DriverRouteBreakdown
                data={data}
                steps={stops}
                textColor={data?.vehicle}
              />
            )}
            <Button
              onClick={() => setIsTrackingCurrentUser(true)}
              disabled={isTrackingCurrentUser}
              variant={isTrackingCurrentUser ? "secondary" : "default"}
            >
              {isTrackingCurrentUser && <LoadingIndicator />}
              {isTrackingCurrentUser
                ? "Broadcasting location with dispatch..."
                : "Start Route"}
            </Button>{" "}
            {isTrackingCurrentUser && (
              <Button
                onClick={() => setIsTrackingCurrentUser(false)}
                variant={"default"}
              >
                Stop broadcasting location with dispatch
              </Button>
            )}
            {selectedStop && (
              <StopDetails open={open} setOpen={setOpen} routeData={data} />
            )}
          </div>
        </section>
        <section className="z-0 flex w-full flex-col lg:w-7/12 xl:w-9/12">
          {data?.geometry && stops && (
            <LazyDriverMap
              steps={stops}
              geometry={data?.geometry}
              focusedStop={selectedStop}
              vehicleId={data?.vehicle}
            />
          )}
        </section>
      </RouteLayout>
    </>
  );
};

export const getServerSideProps = async (
  context: GetServerSidePropsContext
) => {
  const { data, error } = await supabase.storage
    .from("routes")
    .download(`${context.query.route as string}.json`);

  if (!data || error)
    return {
      redirect: {
        destination: `/tools/routing`,
        permanent: false,
      },
    };

  const jsonObject = await parseIncomingDBData(data);

  return { props: { data: jsonObject, steps: jsonObject.steps } };
};

export default RoutePage;
